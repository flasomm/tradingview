//@version=5
indicator("Magnetic Levels: Top & Bottom (All Timeframes)", overlay=true)

// === Types and Structures ===
type LevelData
    float high
    float low
    int highTime
    int lowTime
    line highLine
    line lowLine
    label highLabel
    label lowLabel
    string highText
    string lowText
    color levelColor

type Level
    float price
    int time
    string label
    color col
    string priority

// === Constants ===
var int YEAR_MS = 365 * 24 * 60 * 60 * 1000
var int LABEL_OFFSET = 10

// === User Parameters ===
defaultColor = color.new(color.white, 50)

// Previous High/Low
showMonday   = input.bool(true, "Monday", inline="vsettings", group="Previous High/Low")
colorMonday  = input.color(defaultColor, "", inline="vsettings", group="Previous High/Low")
showDay      = input.bool(true, "D", inline="vsettings", group="Previous High/Low")
colorDay     = input.color(defaultColor, "", inline="vsettings", group="Previous High/Low")
showWeek     = input.bool(true, "W", inline="vsettings", group="Previous High/Low")
colorWeek    = input.color(defaultColor, "", inline="vsettings", group="Previous High/Low")
showMonth    = input.bool(true, "M", inline="vsettings", group="Previous High/Low")
colorMonth   = input.color(defaultColor, "", inline="vsettings", group="Previous High/Low")

// History Settings
historyLevels = input.int(2, "History of previous levels", minval=1, maxval=12, group="Previous High/Low")
showLabels   = input.bool(true, "Show Labels", inline="showLabels", group="Previous High/Low")
showDates    = input.bool(false, "Show Dates", inline="showLabels", group="Previous High/Low")

// Line Style Setting
lineStyleOpt = input.string("solid", "Line Style", options=["dashed", "solid"], group="Previous High/Low")
lineStyle = lineStyleOpt == "solid" ? line.style_solid : line.style_dashed

// === Global Variables ===
var int labelOffset = 10

// === Structure Initialization ===
var dayLevels = array.new<LevelData>()
var mondayLevels = array.new<LevelData>()
var weekLevels = array.new<LevelData>()
var monthLevels = array.new<LevelData>()

// === Period Detection ===
newDay   = dayofmonth != dayofmonth[1] or month != month[1] or year != year[1]
newWeek  = weekofyear != weekofyear[1]
newMonth = month != month[1]
isMonday = dayofweek == dayofweek.monday

// === Rolling storage for each period ===
// Days
var float[] dayHighs = array.new_float()
var float[] dayLows = array.new_float()
var int[] dayTimes = array.new_int()
if newDay
    array.unshift(dayHighs, high)
    array.unshift(dayLows, low)
    array.unshift(dayTimes, time)
else
    if array.size(dayHighs) > 0
        array.set(dayHighs, 0, math.max(array.get(dayHighs, 0), high))
        array.set(dayLows, 0, math.min(array.get(dayLows, 0), low))
while array.size(dayHighs) > historyLevels
    array.pop(dayHighs)
    array.pop(dayLows)
    array.pop(dayTimes)

// Mondays
var float[] mondayHighs = array.new_float()
var float[] mondayLows = array.new_float()
var int[] mondayTimes = array.new_int()
if newDay and dayofweek == dayofweek.monday
    array.unshift(mondayHighs, high)
    array.unshift(mondayLows, low)
    array.unshift(mondayTimes, time)
else
    if array.size(mondayHighs) > 0 and dayofweek == dayofweek.monday
        array.set(mondayHighs, 0, math.max(array.get(mondayHighs, 0), high))
        array.set(mondayLows, 0, math.min(array.get(mondayLows, 0), low))
while array.size(mondayHighs) > historyLevels
    array.pop(mondayHighs)
    array.pop(mondayLows)
    array.pop(mondayTimes)

// Weeks
var float[] weekHighs = array.new_float()
var float[] weekLows = array.new_float()
var int[] weekTimes = array.new_int()
if newWeek
    array.unshift(weekHighs, high)
    array.unshift(weekLows, low)
    array.unshift(weekTimes, time)
else
    if array.size(weekHighs) > 0
        array.set(weekHighs, 0, math.max(array.get(weekHighs, 0), high))
        array.set(weekLows, 0, math.min(array.get(weekLows, 0), low))
while array.size(weekHighs) > historyLevels
    array.pop(weekHighs)
    array.pop(weekLows)
    array.pop(weekTimes)

// Months
var float[] monthHighs = array.new_float()
var float[] monthLows = array.new_float()
var int[] monthTimes = array.new_int()
if newMonth
    array.unshift(monthHighs, high)
    array.unshift(monthLows, low)
    array.unshift(monthTimes, time)
else
    if array.size(monthHighs) > 0
        array.set(monthHighs, 0, math.max(array.get(monthHighs, 0), high))
        array.set(monthLows, 0, math.min(array.get(monthLows, 0), low))
while array.size(monthHighs) > historyLevels
    array.pop(monthHighs)
    array.pop(monthLows)
    array.pop(monthTimes)

// === Utility Functions ===
formatDate(t) =>
    showDates ? str.format("{0,date,yyyy-MM-dd}", t) : ""

updateLevel(level, show, isNewPeriod, newHigh, newLow, newTime) =>
    if show and isNewPeriod and not na(level.highTime)
        line.delete(level.highLine)
        label.delete(level.highLabel)
        level.highLine := line.new(x1=level.highTime, y1=level.high, x2=time, y2=level.high, extend=extend.right, color=level.levelColor, style=lineStyle, xloc=xloc.bar_time)
        level.highLabel := showLabels ? label.new(x=bar_index + labelOffset, y=level.high, text=level.highText + (showDates ? " " + formatDate(level.highTime) : ""), style=label.style_none, textcolor=level.levelColor, xloc=xloc.bar_index) : na

    if show and isNewPeriod and not na(level.lowTime)
        line.delete(level.lowLine)
        label.delete(level.lowLabel)
        level.lowLine := line.new(x1=level.lowTime, y1=level.low, x2=time, y2=level.low, extend=extend.right, color=level.levelColor, style=lineStyle, xloc=xloc.bar_time)
        level.lowLabel := showLabels ? label.new(x=bar_index + labelOffset, y=level.low, text=level.lowText + (showDates ? " " + formatDate(level.lowTime) : ""), style=label.style_none, textcolor=level.levelColor, xloc=xloc.bar_index) : na

    if isNewPeriod
        level.high := newHigh
        level.low := newLow
        level.highTime := newTime
        level.lowTime := newTime
    else
        if newHigh > level.high
            level.high := newHigh
            level.highTime := newTime
        if newLow < level.low
            level.low := newLow
            level.lowTime := newTime

// === Level Updates ===
if array.size(dayHighs) > 0
    for i = 0 to array.size(dayHighs) - 1
        updateLevel(array.get(dayLevels, i), showDay, true, array.get(dayHighs, i), array.get(dayLows, i), array.get(dayTimes, i))
if array.size(mondayHighs) > 0
    for i = 0 to array.size(mondayHighs) - 1
        updateLevel(array.get(mondayLevels, i), showMonday, true, array.get(mondayHighs, i), array.get(mondayLows, i), array.get(mondayTimes, i))
if array.size(weekHighs) > 0
    for i = 0 to array.size(weekHighs) - 1
        updateLevel(array.get(weekLevels, i), showWeek, true, array.get(weekHighs, i), array.get(weekLows, i), array.get(weekTimes, i))
if array.size(monthHighs) > 0
    for i = 0 to array.size(monthHighs) - 1
        updateLevel(array.get(monthLevels, i), showMonth, true, array.get(monthHighs, i), array.get(monthLows, i), array.get(monthTimes, i))

// Repérage des changements de période
if newDay
    array.unshift(dayTimes, bar_index)
    if dayofweek == dayofweek.monday
        array.unshift(mondayTimes, bar_index)
if newWeek
    array.unshift(weekTimes, bar_index)
if newMonth
    array.unshift(monthTimes, bar_index)

// Limiter la taille des tableaux à historyLevels
while array.size(dayTimes) > historyLevels
    array.pop(dayTimes)
while array.size(mondayTimes) > historyLevels
    array.pop(mondayTimes)
while array.size(weekTimes) > historyLevels
    array.pop(weekTimes)
while array.size(monthTimes) > historyLevels
    array.pop(monthTimes) 